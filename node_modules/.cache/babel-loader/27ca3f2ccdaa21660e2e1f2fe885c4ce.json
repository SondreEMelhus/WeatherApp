{"ast":null,"code":"//The code below has been taken from: https://github.com/kaxada/search-bar/blob/main/src/trie.js\n//All credit goes to the original author\nfunction TrieNode(letter) {\n  // properties \n  this.letter = letter;\n  this.prevLetter = null;\n  this.nextLetters = {}; // an object for the following letters\n\n  this.isComplete = false; // check whether letter is last of word\n  //methods\n\n  this.getWord = getWord; // iterates through nodes to get word prediction\n\n  function getWord() {\n    var node = this;\n    var wordLetters = [];\n\n    while (node.prevLetter) {\n      wordLetters.unshift(node.letter);\n      node = node.prevLetter; // set the previous letter as node\n    }\n\n    return wordLetters.join(\"\");\n  }\n\n  ;\n}\n\n_c = TrieNode;\n\nfunction Trie() {\n  // properties\n  this.root = new TrieNode(null); // methods\n\n  this.insert = insert; // insert new word in trie\n\n  this.contains = contains; // check if word exists\n\n  this.find = find; // find words similar with previous letters\n  // insert new word in Trie\n\n  function insert(word) {\n    var node = this.root; // set first node to root node\n\n    for (let i = 0; i < word.length; i++) {\n      const current_letter = word[i];\n\n      if (!node.nextLetters[current_letter]) {\n        // if letter not in next letters\n        node.nextLetters[current_letter] = new TrieNode(current_letter); // make it node\n\n        node.nextLetters[current_letter].prevLetter = node; // add it as a child node\n      }\n\n      node = node.nextLetters[current_letter]; // reset node to current letter & continue iteration\n      // check whether whole word is inserted\n\n      if (i === word.length - 1) {\n        node.isComplete = true;\n      }\n    }\n  }\n\n  ; // check if word exists\n\n  function contains(word) {\n    var node = this.root; // set first node to root node\n\n    for (let i = 0; i < word.length; i++) {\n      const current_letter = word[i];\n      let next_node = node.nextLetters[current_letter];\n\n      if (next_node) {\n        // if letter is one of next letters\n        node = next_node; // set it as a next node\n      } else {\n        return false;\n      }\n    }\n\n    return node.isComplete; // definitely returns 'true'\n  }\n\n  ; // find words with similar previous letters\n\n  function find(clue_letters) {\n    var node = this.root; // set first node to root node\n\n    var output = [];\n\n    for (let i = 0; i < clue_letters.length; i++) {\n      const clue_letter = clue_letters[i];\n      let next_node = node.nextLetters[clue_letter];\n\n      if (next_node) {\n        // if clue letter is one of next letters\n        node = next_node; // set it as next node\n      } else {\n        return output;\n      }\n    } // use the last node to find the next possible words\n\n\n    findAllWords(node, output);\n    return output;\n  }\n\n  ; // function that finds next possible words\n\n  function findAllWords(node, arr) {\n    if (node.isComplete) {\n      // check if node is end node\n      arr.unshift(node.getWord()); // get all words and add them to array\n    } // otherwise recursively call the next nodes\n\n\n    for (var next_letter in node.nextLetters) {\n      findAllWords(node.nextLetters[next_letter], arr);\n    }\n  }\n}\n\n_c2 = Trie;\nexport default Trie;\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"TrieNode\");\n$RefreshReg$(_c2, \"Trie\");","map":{"version":3,"sources":["/Users/sondremelhus/DEV/ReactApps/weatherapp/src/componentes/Searchbar/trie.js"],"names":["TrieNode","letter","prevLetter","nextLetters","isComplete","getWord","node","wordLetters","unshift","join","Trie","root","insert","contains","find","word","i","length","current_letter","next_node","clue_letters","output","clue_letter","findAllWords","arr","next_letter"],"mappings":"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","sourcesContent":["//The code below has been taken from: https://github.com/kaxada/search-bar/blob/main/src/trie.js\n//All credit goes to the original author\n\nfunction TrieNode(letter) {\n    // properties \n    this.letter = letter;\n    this.prevLetter = null;\n    this.nextLetters = {}; // an object for the following letters\n    this.isComplete = false; // check whether letter is last of word\n  \n    //methods\n    this.getWord = getWord;\n  \n    // iterates through nodes to get word prediction\n    function getWord() {\n      var node = this;\n      var wordLetters = [];\n      while (node.prevLetter) {\n        wordLetters.unshift(node.letter);\n        node = node.prevLetter; // set the previous letter as node\n      }\n      return wordLetters.join(\"\");\n    };\n  }\n  \n  function Trie() {\n    // properties\n    this.root = new TrieNode(null);\n  \n    // methods\n    this.insert = insert; // insert new word in trie\n    this.contains = contains; // check if word exists\n    this.find = find; // find words similar with previous letters\n  \n    // insert new word in Trie\n    function insert(word) {\n      var node = this.root; // set first node to root node\n      for (let i = 0; i < word.length; i++) {\n        const current_letter = word[i];\n        if (!node.nextLetters[current_letter]) { // if letter not in next letters\n          node.nextLetters[current_letter] = new TrieNode(current_letter); // make it node\n          node.nextLetters[current_letter].prevLetter = node; // add it as a child node\n        }\n        node = node.nextLetters[current_letter]; // reset node to current letter & continue iteration\n  \n        // check whether whole word is inserted\n        if (i === word.length - 1) {\n          node.isComplete = true;\n        }\n      }\n    };\n  \n    // check if word exists\n    function contains(word) {\n      var node = this.root; // set first node to root node\n      for (let i = 0; i < word.length; i++) {\n        const current_letter = word[i];\n        let next_node = node.nextLetters[current_letter];\n        if (next_node) { // if letter is one of next letters\n          node = next_node; // set it as a next node\n        } else {\n          return false;\n        }\n      }\n      return node.isComplete; // definitely returns 'true'\n    };\n  \n    // find words with similar previous letters\n    function find(clue_letters) {\n      var node = this.root; // set first node to root node\n      var output = [];\n      for (let i = 0; i < clue_letters.length; i++) {\n        const clue_letter = clue_letters[i];\n        let next_node = node.nextLetters[clue_letter];\n        if (next_node) { // if clue letter is one of next letters\n          node = next_node; // set it as next node\n        } else {\n          return output;\n        }\n      }\n  \n      // use the last node to find the next possible words\n      findAllWords(node, output);\n      return output;\n    };\n  \n    // function that finds next possible words\n    function findAllWords(node, arr) {\n      if (node.isComplete) { // check if node is end node\n        arr.unshift(node.getWord()); // get all words and add them to array\n      }\n  \n      // otherwise recursively call the next nodes\n      for (var next_letter in node.nextLetters) {\n        findAllWords(node.nextLetters[next_letter], arr);\n      }\n    }\n  }\n  \n  export default Trie;\n  "]},"metadata":{},"sourceType":"module"}